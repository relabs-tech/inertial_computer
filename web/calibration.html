<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IMU Calibration - Inertial Computer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root {
      --bg: #05060a;
      --card-bg: #15171c;
      --text: #e5e5e5;
      --muted: #999;
      --accent: #4fc3f7;
      --success: #4caf50;
      --warning: #ff9800;
      --error: #f44336;
      --shadow: 0 18px 40px rgba(0, 0, 0, 0.7);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #10131a 0, #05060a 45%, #000 100%);
      color: var(--text);
      overflow-x: hidden;
    }

    .page {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 2rem 1rem;
    }

    .container {
      width: 100%;
      max-width: 1200px;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      margin: 0 0 0.5rem;
      font-size: 2rem;
      font-weight: 600;
      color: var(--accent);
    }

    .back-button {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: var(--card-bg);
      color: var(--text);
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .back-button:hover {
      background: #25272c;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }

    .viz-section {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
    }

    .viz-title {
      font-size: 1.2rem;
      margin: 0 0 1rem;
      color: var(--accent);
    }

    #scene-container {
      width: 100%;
      height: 400px;
      border-radius: 8px;
      overflow: hidden;
      background: #000;
    }

    .instructions-section {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
    }

    .phase-indicator {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #333;
    }

    .phase-step {
      flex: 1;
      text-align: center;
      padding: 0.5rem;
      border-radius: 8px;
      font-size: 0.85rem;
      opacity: 0.4;
      transition: all 0.3s ease;
    }

    .phase-step.active {
      opacity: 1;
      background: rgba(79, 195, 247, 0.2);
      border: 1px solid var(--accent);
    }

    .phase-step.complete {
      opacity: 0.8;
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid var(--success);
    }

    .instruction-text {
      font-size: 1.1rem;
      line-height: 1.6;
      margin-bottom: 1.5rem;
      flex: 1;
    }

    .step-title {
      font-size: 1.3rem;
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .step-detail {
      color: var(--muted);
      margin-bottom: 1rem;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 1.5rem;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--success));
      width: 0%;
      transition: width 0.3s ease;
    }

    .action-buttons {
      display: flex;
      gap: 1rem;
    }

    .button {
      flex: 1;
      padding: 1rem 2rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .button-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .button-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }

    .button-secondary {
      background: var(--card-bg);
      color: var(--text);
      border: 1px solid #333;
    }

    .button-secondary:hover:not(:disabled) {
      background: #25272c;
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .imu-selector {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
      margin-bottom: 2rem;
      text-align: center;
    }

    .imu-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
      margin-top: 1rem;
    }

    .imu-button {
      padding: 1rem 2rem;
      border: 2px solid #333;
      background: var(--card-bg);
      color: var(--text);
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .imu-button:hover {
      border-color: var(--accent);
      background: #25272c;
    }

    .imu-button.selected {
      border-color: var(--accent);
      background: rgba(79, 195, 247, 0.2);
    }

    .stats-section {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .stat-item {
      background: #0a0b0f;
      padding: 1rem;
      border-radius: 8px;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--accent);
    }

    .hidden {
      display: none !important;
    }

    .success-message {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid var(--success);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      font-size: 1.1rem;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <button class="back-button" onclick="window.location.href='/'">‚Üê Back to Dashboard</button>
  
  <div class="page">
    <div class="container">
      <div class="header">
        <h1>üéØ IMU Calibration</h1>
        <p style="color: var(--muted);">Interactive calibration for gyroscope, accelerometer, and magnetometer</p>
      </div>

      <!-- IMU Selector -->
      <div id="imu-selector" class="imu-selector">
        <h2 class="viz-title">Select IMU to Calibrate</h2>
        <p style="color: var(--muted); margin-bottom: 1rem;">Choose which IMU sensor you want to calibrate</p>
        <div class="imu-buttons">
          <button class="imu-button" onclick="selectIMU('left')">Left IMU</button>
          <button class="imu-button" onclick="selectIMU('right')">Right IMU</button>
        </div>
      </div>

      <!-- Main Calibration Interface -->
      <div id="calibration-interface" class="hidden">
        <div class="main-content">
          <!-- 3D Visualization -->
          <div class="viz-section">
            <h2 class="viz-title">Device Orientation</h2>
            <div id="scene-container"></div>
            <div style="margin-top: 1rem; text-align: center; color: var(--muted); font-size: 0.85rem;">
              <span id="orientation-hint">Position your device as shown</span>
            </div>
          </div>

          <!-- Instructions -->
          <div class="instructions-section">
            <div class="phase-indicator">
              <div class="phase-step" id="phase-gyro">Gyroscope</div>
              <div class="phase-step" id="phase-accel">Accelerometer</div>
              <div class="phase-step" id="phase-mag">Magnetometer</div>
            </div>

            <div class="instruction-text">
              <div class="step-title" id="step-title">Preparing calibration...</div>
              <div class="step-detail" id="step-detail">Initializing sensors and preparing calibration sequence</div>
            </div>

            <div class="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
            </div>

            <div class="action-buttons">
              <button class="button button-secondary" onclick="cancelCalibration()">Cancel</button>
              <button class="button button-primary" id="action-button" onclick="nextStep()" disabled>Start</button>
            </div>
          </div>
        </div>

        <!-- Statistics -->
        <div class="stats-section">
          <h2 class="viz-title">Calibration Statistics</h2>
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">Gyro Confidence</div>
              <div class="stat-value" id="stat-gyro">--</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Accel Confidence</div>
              <div class="stat-value" id="stat-accel">--</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Mag Confidence</div>
              <div class="stat-value" id="stat-mag">--</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Total Samples</div>
              <div class="stat-value" id="stat-samples">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, device;
    let selectedIMU = null;
    let currentPhase = null;
    let currentStep = null;
    let ws = null;

    // Calibration state machine
    const phases = {
      gyro: {
        name: 'Gyroscope',
        steps: [
          { id: 'gyro-static', title: 'Static Calibration', detail: 'Place the device on a flat, stable surface and keep it completely still for 10 seconds.' },
          { id: 'gyro-x', title: 'X-Axis Rotation', detail: 'Slowly rotate the device around the X-axis (pitch forward/backward). Make smooth, controlled movements.' },
          { id: 'gyro-y', title: 'Y-Axis Rotation', detail: 'Slowly rotate the device around the Y-axis (roll left/right). Keep movements smooth and steady.' },
          { id: 'gyro-z', title: 'Z-Axis Rotation', detail: 'Slowly rotate the device around the Z-axis (yaw/spin). Complete at least one full rotation.' }
        ]
      },
      accel: {
        name: 'Accelerometer',
        steps: [
          { id: 'accel-up', title: 'Z+ Up', detail: 'Place device flat with Z-axis pointing up. Hold steady for 5 seconds.' },
          { id: 'accel-down', title: 'Z- Down', detail: 'Flip device upside down with Z-axis pointing down. Hold steady for 5 seconds.' },
          { id: 'accel-right', title: 'X+ Right', detail: 'Rotate device so X-axis points up. Hold steady for 5 seconds.' },
          { id: 'accel-left', title: 'X- Left', detail: 'Flip so X-axis points down. Hold steady for 5 seconds.' },
          { id: 'accel-forward', title: 'Y+ Forward', detail: 'Rotate so Y-axis points up. Hold steady for 5 seconds.' },
          { id: 'accel-back', title: 'Y- Back', detail: 'Flip so Y-axis points down. Hold steady for 5 seconds.' }
        ]
      },
      mag: {
        name: 'Magnetometer',
        steps: [
          { id: 'mag-calibrate', title: 'Magnetometer Calibration', detail: 'Move the device in a figure-8 pattern, rotating it in all directions. Cover as many orientations as possible for 20 seconds.' }
        ]
      }
    };

    function initThreeJS() {
      const container = document.getElementById('scene-container');
      
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      
      // Camera
      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);
      
      // Create device representation (box with colored axes)
      const geometry = new THREE.BoxGeometry(2, 1, 0.2);
      const material = new THREE.MeshPhongMaterial({ color: 0x667eea });
      device = new THREE.Mesh(geometry, material);
      scene.add(device);
      
      // Add axis indicators
      const axisLength = 1.5;
      const xAxis = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), axisLength, 0xff0000);
      const yAxis = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), axisLength, 0x00ff00);
      const zAxis = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), axisLength, 0x0000ff);
      device.add(xAxis);
      device.add(yAxis);
      device.add(zAxis);
      
      // Grid
      const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
      scene.add(gridHelper);
      
      animate();
      
      // Handle window resize
      window.addEventListener('resize', () => {
        const width = container.clientWidth;
        const height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      
      // Auto-rotate slightly for visual interest when not animating specific orientation
      if (!currentStep || currentStep.id === 'gyro-static') {
        device.rotation.y += 0.005;
      }
      
      renderer.render(scene, camera);
    }

    function animateDeviceOrientation(stepId) {
      // Reset rotation
      device.rotation.set(0, 0, 0);
      
      // Set target orientation based on step
      switch(stepId) {
        case 'gyro-x':
          device.rotation.x = Math.PI / 4;
          break;
        case 'gyro-y':
          device.rotation.y = Math.PI / 4;
          break;
        case 'gyro-z':
          device.rotation.z = Math.PI / 4;
          break;
        case 'accel-up':
          device.rotation.set(0, 0, 0);
          break;
        case 'accel-down':
          device.rotation.set(Math.PI, 0, 0);
          break;
        case 'accel-right':
          device.rotation.set(0, 0, -Math.PI / 2);
          break;
        case 'accel-left':
          device.rotation.set(0, 0, Math.PI / 2);
          break;
        case 'accel-forward':
          device.rotation.set(Math.PI / 2, 0, 0);
          break;
        case 'accel-back':
          device.rotation.set(-Math.PI / 2, 0, 0);
          break;
        case 'mag-calibrate':
          // Figure-8 animation
          animateFigure8();
          break;
      }
    }

    function animateFigure8() {
      let time = 0;
      const figure8Interval = setInterval(() => {
        time += 0.05;
        device.rotation.x = Math.sin(time) * Math.PI / 3;
        device.rotation.y = Math.sin(time * 2) * Math.PI / 3;
        device.rotation.z = Math.cos(time) * Math.PI / 4;
        
        if (currentStep && currentStep.id !== 'mag-calibrate') {
          clearInterval(figure8Interval);
        }
      }, 50);
    }

    function selectIMU(imu) {
      selectedIMU = imu;
      
      // Update UI
      document.querySelectorAll('.imu-button').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');
      
      // Show calibration interface
      setTimeout(() => {
        document.getElementById('imu-selector').classList.add('hidden');
        document.getElementById('calibration-interface').classList.remove('hidden');
        initThreeJS();
        connectWebSocket();
        document.getElementById('action-button').disabled = false;
        document.getElementById('action-button').textContent = 'Start Calibration';
      }, 300);
    }

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}/api/calibration/ws`);
      
      ws.onopen = () => {
        console.log('WebSocket connected');
        ws.send(JSON.stringify({ action: 'init', imu: selectedIMU }));
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
      
      ws.onclose = () => {
        console.log('WebSocket closed');
      };
    }

    function handleWebSocketMessage(data) {
      switch(data.type) {
        case 'phase':
          updatePhase(data.phase);
          break;
        case 'step':
          updateStep(data.step, data.phase);
          break;
        case 'progress':
          updateProgress(data.progress);
          break;
        case 'stats':
          updateStats(data.stats);
          break;
        case 'action':
          // Re-enable the action button
          document.getElementById('action-button').disabled = false;
          document.getElementById('action-button').textContent = 'Next Step';
          break;
        case 'complete':
          showComplete(data.results);
          break;
        case 'error':
          showError(data.message);
          break;
      }
    }

    function updatePhase(phase) {
      currentPhase = phase;
      
      // Update phase indicators
      document.querySelectorAll('.phase-step').forEach(step => {
        step.classList.remove('active', 'complete');
      });
      
      const phaseElement = document.getElementById(`phase-${phase}`);
      if (phaseElement) {
        phaseElement.classList.add('active');
      }
      
      // Mark previous phases as complete
      const phaseOrder = ['gyro', 'accel', 'mag'];
      const currentIndex = phaseOrder.indexOf(phase);
      for (let i = 0; i < currentIndex; i++) {
        document.getElementById(`phase-${phaseOrder[i]}`).classList.add('complete');
      }
    }

    function updateStep(step, phase) {
      const phaseData = phases[phase];
      const stepData = phaseData.steps.find(s => s.id === step);
      
      if (stepData) {
        currentStep = stepData;
        document.getElementById('step-title').textContent = stepData.title;
        document.getElementById('step-detail').textContent = stepData.detail;
        animateDeviceOrientation(stepData.id);
      }
    }

    function updateProgress(progress) {
      document.getElementById('progress-fill').style.width = `${progress}%`;
    }

    function updateStats(stats) {
      if (stats.gyro !== undefined) {
        document.getElementById('stat-gyro').textContent = stats.gyro.toFixed(1);
      }
      if (stats.accel !== undefined) {
        document.getElementById('stat-accel').textContent = stats.accel.toFixed(1);
      }
      if (stats.mag !== undefined) {
        document.getElementById('stat-mag').textContent = stats.mag.toFixed(1);
      }
      if (stats.samples !== undefined) {
        document.getElementById('stat-samples').textContent = stats.samples;
      }
    }

    function showComplete(results) {
      document.getElementById('step-title').textContent = '‚úÖ Calibration Complete!';
      document.getElementById('step-detail').innerHTML = `
        Calibration successful. Results saved to:<br>
        <code style="color: var(--accent);">${results.filename}</code>
      `;
      document.getElementById('action-button').textContent = 'Done';
      document.getElementById('action-button').onclick = () => window.location.href = '/';
      document.getElementById('progress-fill').style.width = '100%';
      
      // Mark all phases complete
      document.querySelectorAll('.phase-step').forEach(step => {
        step.classList.remove('active');
        step.classList.add('complete');
      });
    }

    function showError(message) {
      document.getElementById('step-title').textContent = '‚ùå Error';
      document.getElementById('step-detail').textContent = message;
      document.getElementById('action-button').textContent = 'Retry';
      document.getElementById('action-button').onclick = () => location.reload();
    }

    function nextStep() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.error('WebSocket not connected');
        return;
      }
      
      ws.send(JSON.stringify({ action: 'next' }));
      document.getElementById('action-button').disabled = true;
      document.getElementById('action-button').textContent = 'In Progress...';
    }

    function cancelCalibration() {
      if (ws) {
        ws.send(JSON.stringify({ action: 'cancel' }));
        ws.close();
      }
      window.location.href = '/';
    }
  </script>
</body>
</html>
